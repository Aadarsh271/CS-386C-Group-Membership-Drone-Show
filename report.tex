\documentclass[11pt]{article}

\usepackage{amsmath, amssymb, amsthm}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}

\geometry{margin=1in}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  breaklines=true,
  frame=single,
  language=C++
}

\title{%
  \textbf{Neighborhood Surveillance Group Membership Protocol}\\[0.5em]
  \large For Distributed Drone Swarm Coordination
}
\author{Project Documentation}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This report describes the design and implementation of a distributed group membership protocol for drone swarms, based on Cristian’s neighborhood surveillance model (1991). The approach reduces monitoring overhead by having each node observe only its nearest neighbors, rather than all peers. This yields scalable fault detection while maintaining correctness under partial synchrony assumptions.  
In addition to core membership management, the implementation includes a visualization system, a configurable network simulator, and support for formation control. The resulting system provides a practical and extensible framework for experimentation in robust swarm coordination.
\end{abstract}

\tableofcontents
\newpage

% =============================================================================
\section{Introduction}
% =============================================================================

Coordinating a swarm of autonomous drones requires a reliable understanding of which nodes are currently active. Because drones may fail due to battery depletion, communication loss, or environmental hazards, establishing a consistent view of group membership is foundational to any higher-level behavior.

A naive solution---having each drone monitor all others---results in $O(n^2)$ heartbeat traffic and becomes impractical for larger swarms. Cristian's 1991 work demonstrated that a ring-based neighborhood-surveillance structure enables every failure to be detected while reducing per-node monitoring overhead to $O(1)$.

This project implements a proximity-based variant of Cristian’s approach. Key extensions and differences include:
\begin{itemize}[noitemsep]
    \item Neighbors are selected using Euclidean distance rather than ring indices.
    \item Drones exchange positions during reconfiguration to ensure consistent neighbor assignment.
    \item A visualization system facilitates debugging and analysis.
    \item Formation control features are integrated for evaluation and demonstration purposes.
\end{itemize}

% =============================================================================
\section{Background}
% =============================================================================

\subsection{The Group Membership Problem}

Maintaining a correct set of active participants in a distributed system is challenging due to message delays, loss, and node failures. Distinguishing slow communication from genuine failure is inherently ambiguous under asynchrony. 

Practical systems assume \emph{partial synchrony}: messages arrive within an unknown but bounded delay. This assumption is suitable for drone networks, where communication characteristics are reasonably constrained.

\subsection{Cristian's Insight}

Cristian's neighborhood-surveillance model arranges nodes in a logical ring, assigning each node two monitors. A single failure is guaranteed to be detected by at least one neighbor. This reduces monitoring complexity while ensuring complete coverage. The tradeoff is a potentially longer propagation delay before the entire group converges on a consistent view.

% =============================================================================
\section{Protocol Overview}
% =============================================================================

\subsection{State and Neighbor Selection}

Each drone maintains:
\begin{itemize}[noitemsep]
    \item Its two geographically closest neighbors.
    \item Timestamps of the most recent heartbeat from each neighbor.
    \item Its current group membership identifier.
    \item Whether a reconfiguration process is active.
\end{itemize}

Proximity-based neighborhood selection improves communication reliability at the cost of dynamic neighbor changes as drones move.

\subsection{Heartbeats}

Every \texttt{heartbeatInterval} seconds, each drone sends:
\begin{verbatim}
HEARTBEAT {
    senderId,
    position,
    timestamp
}
\end{verbatim}

If a heartbeat is not received within \texttt{heartbeatInterval + timeoutDelta}, the neighbor is suspected failed, and reconfiguration is initiated.

\subsection{Three-Phase Reconfiguration}

Reconfiguration proceeds through three phases. This ensures that all nodes converge not only a consistent view of membership but also a consistent neighbor set to fit the drone problem.

\subsubsection{Phase 1: INIT}

The detecting drone broadcasts:
\begin{verbatim}
RECONFIG_INIT {
    reconfigId,
    initiatorId
}
\end{verbatim}

This message announces the start of a reconfiguration without presupposing the final member set.

\subsubsection{Phase 2: ACK}

Nodes willing to join the new configuration respond with:
\begin{verbatim}
RECONFIG_ACK {
    reconfigId,
    senderId,
    position
}
\end{verbatim}

Including position data ensures consistent neighbor determination after commit.

\subsubsection{Phase 3: COMMIT}

After waiting for acknowledgments, the initiator broadcasts:
\begin{verbatim}
RECONFIG_COMMIT {
    reconfigId,
    initiatorId,
    numMembers,
    members: [{id, position}, ...]
}
\end{verbatim}

Upon receiving the COMMIT message, nodes:
\begin{enumerate}[noitemsep]
    \item Install the new member list.
    \item Update their group identifier.
    \item Recompute neighbors using the supplied positions.
    \item Resume normal monitoring.
\end{enumerate}

\subsection{Tie-Breaking Rules}

Concurrent reconfiguration attempts are resolved using the following logic:

\begin{lstlisting}
if (inReconfig) {
    if (newReconfigId < pendingReconfigId)
        return;

    if (newReconfigId == pendingReconfigId &&
        newInitiatorId >= currentInitiatorId)
        return;

    // Otherwise, switch to the newer reconfiguration
}
\end{lstlisting}

More recent \texttt{reconfigId} values dominate; ties are broken by initiator ID. This deterministic ordering ensures convergence.

% =============================================================================
\section{Network Simulation}
% =============================================================================

A configurable network simulator models realistic communication conditions.

\subsection{Latency Model}

\[
\text{delay} = \text{baseLatency} + \alpha \cdot \text{load} + \beta \cdot \text{distance}
\]

\subsection{Packet Loss}

\[
P(\text{drop}) = \text{baseLossProb} + \gamma \cdot \text{load}
\]

A burst-loss mode simulates temporary interference by introducing correlated packet drops.

\subsection{Additional Impairments}

\begin{itemize}[noitemsep]
    \item \textbf{Duplication}: Models non-idempotent network paths.
    \item \textbf{Jitter}: Adds timing variability.
    \item \textbf{Omissions}: Represents local processing delays or missed transmissions.
\end{itemize}

% =============================================================================
\section{Visualization System}
% =============================================================================

\subsection{Membership Visualization}

This mode displays:
\begin{itemize}[noitemsep]
    \item Alive and failed nodes.
    \item Neighbor relationships.
    \item Heartbeat and broadcast traffic.
\end{itemize}

System state indicators visualize consistency and failure detections.

\subsection{Formation Visualization}

A secondary mode renders formation transitions with smooth interpolation and color gradients. Although not required for the protocol, this mode aids demonstration and provides a clear illustration of swarm responsiveness to membership changes.

% =============================================================================
\section{Testing and Failure Scenarios}
% =============================================================================

\subsection{Cascading Failures}

A worst-case scenario involves sequential failure of neighbors faster than the detection timeout. While theoretically challenging, the protocol still guarantees that surviving nodes converge on a correct membership.

\subsection{Test Suite}

The test harness covers normal operation, isolated failures, adjacent failures, cascading failures, simultaneous failures, and operation under realistic network conditions. Tests use both deterministic and probabilistic network models.

% =============================================================================
\section{Implementation Details}
% =============================================================================

\subsection{Code Structure}

\begin{verbatim}
src/
  core/                  Main simulation loop and drone logic
  membership/            Membership protocol implementation
  network/               Network simulator
  control/               Formation controller
  visualization/         Rendering subsystem
  util/                  Logging utilities
\end{verbatim}

The membership implementation is intentionally isolated to promote clarity and testability.

\subsection{Logging}

Logging is grouped by category (Heartbeats, Reconfig, Failures, Messages) and can be enabled or disabled at runtime.

% =============================================================================
\section{Protocol Properties}
% =============================================================================

\subsection{Safety}

\begin{enumerate}[noitemsep]
    \item \textbf{Agreement}: Nodes sharing the same group ID share the same member list.
    \item \textbf{Validity}: Only nodes that send ACKs appear in a COMMIT message.
    \item \textbf{Non-inclusion of failed nodes}: Failed nodes cannot contribute ACKs and therefore cannot appear in new membership lists.
\end{enumerate}

\subsection{Liveness}

\begin{enumerate}[noitemsep]
    \item \textbf{Failure detection}: Missing heartbeats eventually trigger detection.
    \item \textbf{Termination}: Every reconfiguration completes within a bounded number of rounds.
\end{enumerate}

\subsection{Timing}

\[
T \approx (h + \delta) + \Delta_1 + 2\Delta_2 + \Delta_1
      \approx 4.5 \text{ seconds (default parameters)}
\]

% =============================================================================
\section{Configuration}
% =============================================================================

All parameters are defined in \texttt{SimulationConfig.h} and adjustable via GUI.

\subsection{Protocol Timing}
\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
Parameter & Default & Description \\
\midrule
heartbeatInterval & 2.0s & Heartbeat period \\
timeoutDelta & 0.6s & Failure detection margin \\
deltaSmall & 0.5s & Upper bound on message delay \\
deltaLarge & 0.5s & ACK collection window \\
reconfigMinInterval & 1.0s & Minimum spacing between reconfigs \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Network Parameters}
\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
Parameter & Default & Description \\
\midrule
baseLatency & 0.05s & Minimum latency \\
baseLossProb & 0.0 & Baseline drop probability \\
enableBursts & false & Correlated loss model \\
omissionProb & 0.0 & Chance of skipped sends \\
\bottomrule
\end{tabular}
\end{table}

% =============================================================================
\section{Usage Instructions}
% =============================================================================

\subsection{Building}

\begin{lstlisting}[language=bash]
mkdir build && cd build
cmake ..
cmake --build .
./drone-show
\end{lstlisting}

Dependencies are automatically fetched by CMake during the first build.

% =============================================================================
\section{Future Work}
% =============================================================================

Potential extensions include:
\begin{enumerate}[noitemsep]
    \item Introducing a SUSPECT state to mitigate transient-network false positives.
    \item Supporting $k$-miss failure tolerance.
    \item Implementing a load balancing multiple concurrent group membership protocol.
    \item Creating hierarchical group structures for long distance coordination.
    \item Deploying the protocol on physical drone hardware.
\end{enumerate}

% =============================================================================
\section{Conclusion}
% =============================================================================

This project implements a proximity-based neighborhood-surveillance group membership protocol for drone swarms. The system incorporates robust reconfiguration, a configurable network simulator, a visualization framework, and a comprehensive test suite. The results demonstrate that neighborhood-based monitoring is an effective and scalable approach for swarm coordination under realistic communication conditions.

\end{document}
